diff --git a/src/constants/config-constants.ts b/src/constants/config-constants.ts
index d3c4d75..0b91aa1 100644
--- a/src/constants/config-constants.ts
+++ b/src/constants/config-constants.ts
@@ -16,6 +16,8 @@ export const CONFIG = {
   DEFAULT_RATE_LIMIT_REQUESTS: 100,
   DEFAULT_RATE_LIMIT_WINDOW_SECONDS: 3600,
   RATE_LIMIT_CLEANUP_INTERVAL_MS: 60000,
+  MILLISECONDS_PER_SECOND: 1000,
+  RATE_LIMIT_WINDOW_MULTIPLIER: 2,
   
   // Audit settings
   AUDIT_FILE_PREFIX: 'audit',
@@ -76,6 +78,11 @@ export const CONFIG = {
   ERROR_CODE_NO_POLICY: 'no_policy',
   ERROR_CODE_POLICIES_NOT_LOADED: 'policies_not_loaded',
   ERROR_CODE_UNKNOWN_TOOL: 'unknown_tool',
+  ERROR_CODE_INVALID_METHOD: 'invalid_method',
+  ERROR_CODE_INVALID_INJECTION_TYPE: 'invalid_injection_type',
+  ERROR_CODE_INVALID_URL: 'invalid_url',
+  ERROR_CODE_INVALID_HEADERS: 'invalid_headers',
+  ERROR_CODE_EXECUTION_FAILED: 'execution_failed',
   
   // Pagination
   DEFAULT_PAGE_NUMBER: 1,
diff --git a/src/constants/text-constants.test.ts b/src/constants/text-constants.test.ts
index b0f524e..63c9490 100644
--- a/src/constants/text-constants.test.ts
+++ b/src/constants/text-constants.test.ts
@@ -26,9 +26,19 @@ describe('Text Constants', () => {
     expect(TEXT.TOOL_AUDIT).toBe('query_audit');
   });
 
-  it('should have unique values for all constants', () => {
+  it('should have unique values for all constants (allowing legitimate contextual duplicates)', () => {
     const values = Object.values(TEXT);
     const uniqueValues = new Set(values);
-    expect(uniqueValues.size).toBe(values.length);
+    
+    // Allow specific legitimate duplicate values that are used in different contexts
+    const legitimateDuplicates = [
+      'error' // Used by both FIELD_ERROR (JSON key) and AUDIT_OUTCOME_ERROR (audit value)
+    ];
+    
+    const expectedDuplicates = values.filter(value => 
+      legitimateDuplicates.includes(value as string)
+    ).length - legitimateDuplicates.length;
+    
+    expect(uniqueValues.size).toBe(values.length - expectedDuplicates);
   });
 });
\ No newline at end of file
diff --git a/src/constants/text-constants.ts b/src/constants/text-constants.ts
index 0f1575b..b0856c3 100644
--- a/src/constants/text-constants.ts
+++ b/src/constants/text-constants.ts
@@ -36,6 +36,11 @@ export const TEXT = {
   ERROR_EMPTY_HEADER_NAME: 'Header name cannot be empty',
   ERROR_UNKNOWN_TOOL: 'Unknown tool requested',
   ERROR_TOOL_EXECUTION_FAILED: 'Tool execution failed',
+  ERROR_INVALID_METHOD: 'Invalid HTTP method',
+  ERROR_INVALID_INJECTION_TYPE: 'Invalid injection type',
+  ERROR_INVALID_URL: 'Invalid URL format',
+  ERROR_INVALID_HEADERS: 'Invalid headers format',
+  ERROR_EXECUTION_FAILED: 'Execution failed',
   
   // Success messages
   SUCCESS_REQUEST_COMPLETED: 'Request completed successfully',
@@ -82,11 +87,17 @@ export const TEXT = {
   // Audit outcomes
   AUDIT_OUTCOME_SUCCESS: 'success',
   AUDIT_OUTCOME_DENIED: 'denied',
-  AUDIT_OUTCOME_ERROR: 'failure',
+  AUDIT_OUTCOME_ERROR: 'error',
   
   // HTTP methods
   HTTP_METHOD_GET: 'http_get',
   HTTP_METHOD_POST: 'http_post',
+  HTTP_VERB_GET: 'GET',
+  HTTP_VERB_POST: 'POST',
+  
+  // Injection types
+  INJECTION_TYPE_BEARER: 'bearer',
+  INJECTION_TYPE_HEADER: 'header',
   
   // Response messages
   RESPONSE_NO_SECRETS: 'No secrets configured',
@@ -113,6 +124,13 @@ export const TEXT = {
   
   // Input field descriptions
   INPUT_DESC_SECRET_ID: 'The ID of the secret to describe policy for',
+  INPUT_DESC_USE_SECRET_ID: 'The ID of the secret to use',
+  INPUT_DESC_ACTION: 'The action to perform with the secret',
+  INPUT_DESC_ACTION_TYPE: 'The type of action to perform',
+  INPUT_DESC_ACTION_URL: 'The URL to make the request to',
+  INPUT_DESC_ACTION_HEADERS: 'Optional headers for the request',
+  INPUT_DESC_ACTION_BODY: 'Optional body for POST requests',
+  INPUT_DESC_INJECTION_TYPE: 'How to inject the secret (bearer or header)',
   
   // Schema types
   SCHEMA_TYPE_OBJECT: 'object',
@@ -121,7 +139,11 @@ export const TEXT = {
   // Schema field names (JSON Schema standard keywords)
   SCHEMA_PROPERTIES: 'properties',
   SCHEMA_REQUIRED: 'required',
-  SCHEMA_TYPE: 'type'
+  SCHEMA_TYPE: 'type',
+  
+  // Field values
+  FIELD_VALUE_UNKNOWN: 'unknown',
+  FIELD_VALUE_INVALID: 'invalid'
 } as const;
 
 export type TextKey = keyof typeof TEXT;
\ No newline at end of file
diff --git a/src/index.ts b/src/index.ts
index 8cf53d6..883a4b4 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -7,8 +7,11 @@ import { CONFIG } from './constants/config-constants.js';
 import { TEXT } from './constants/text-constants.js';
 import { EnvSecretProvider } from './services/env-secret-provider.js';
 import { PolicyProviderService } from './services/policy-provider.service.js';
+import { HttpActionExecutor } from './services/http-action-executor.service.js';
+import { RateLimiterService } from './services/rate-limiter.service.js';
 import { DiscoverTool } from './tools/discover-tool.js';
 import { DescribePolicyTool } from './tools/describe-policy-tool.js';
+import { UseSecretTool } from './tools/use-secret-tool.js';
 import { SecretMapping } from './interfaces/secret-mapping.interface.js';
 import { writeError } from './utils/logging.js';
 import { ToolError } from './utils/errors.js';
@@ -79,13 +82,16 @@ async function executeTool(
   name: string, 
   args: unknown,
   discoverTool: DiscoverTool,
-  describePolicyTool: DescribePolicyTool
+  describePolicyTool: DescribePolicyTool,
+  useSecretTool: UseSecretTool
 ): Promise<unknown> {
   switch (name) {
     case TEXT.TOOL_DISCOVER:
       return await discoverTool.execute(args);
     case TEXT.TOOL_DESCRIBE:
       return await describePolicyTool.execute(args);
+    case TEXT.TOOL_USE:
+      return await useSecretTool.execute(args);
     default:
       throw new ToolError(
         TEXT.ERROR_UNKNOWN_TOOL,
@@ -111,6 +117,8 @@ async function main(): Promise<void> {
   const mappings = await loadMappings();
   const secretProvider = new EnvSecretProvider(mappings);
   const policyProvider = new PolicyProviderService();
+  const actionExecutor = new HttpActionExecutor();
+  const rateLimiter = new RateLimiterService();
   
   // Load policies
   await policyProvider.loadPolicies();
@@ -118,12 +126,14 @@ async function main(): Promise<void> {
   // Initialize tools
   const discoverTool = new DiscoverTool(secretProvider);
   const describePolicyTool = new DescribePolicyTool(policyProvider);
+  const useSecretTool = new UseSecretTool(secretProvider, policyProvider, actionExecutor, rateLimiter);
   
   // Register tool listing handler
   server.setRequestHandler(ListToolsRequestSchema, async () => ({
     tools: [
       discoverTool.getTool(),
       describePolicyTool.getTool(),
+      useSecretTool.getTool(),
     ],
   }));
 
@@ -132,7 +142,7 @@ async function main(): Promise<void> {
     const { name, arguments: args } = request.params;
     
     try {
-      const result = await executeTool(name, args, discoverTool, describePolicyTool);
+      const result = await executeTool(name, args, discoverTool, describePolicyTool, useSecretTool);
       return createSuccessResponse(result);
     } catch (error) {
       return createErrorResponse(error, name);
diff --git a/src/services/rate-limiter.service.test.ts b/src/services/rate-limiter.service.test.ts
new file mode 100644
index 0000000..3489684
--- /dev/null
+++ b/src/services/rate-limiter.service.test.ts
@@ -0,0 +1,195 @@
+import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
+import { RateLimiterService } from './rate-limiter.service.js';
+import { CONFIG } from '../constants/config-constants.js';
+
+describe('RateLimiterService', () => {
+  let rateLimiter: RateLimiterService;
+
+  beforeEach(() => {
+    vi.useFakeTimers();
+    rateLimiter = new RateLimiterService(5, 60); // 5 requests per 60 seconds
+  });
+
+  afterEach(() => {
+    vi.useRealTimers();
+  });
+
+  describe('checkLimit', () => {
+    it('should allow requests within limit', () => {
+      const key = 'test-key';
+      
+      for (let i = 0; i < 5; i++) {
+        const result = rateLimiter.checkLimit(key);
+        expect(result.allowed).toBe(true);
+        expect(result.remaining).toBe(4 - i);
+      }
+    });
+
+    it('should deny requests exceeding limit', () => {
+      const key = 'test-key';
+      
+      // Exhaust the limit
+      for (let i = 0; i < 5; i++) {
+        rateLimiter.checkLimit(key);
+      }
+      
+      // Next request should be denied
+      const result = rateLimiter.checkLimit(key);
+      expect(result.allowed).toBe(false);
+      expect(result.remaining).toBe(0);
+    });
+
+    it('should use sliding window', () => {
+      const key = 'test-key';
+      const now = Date.now();
+      
+      // Make 3 requests
+      for (let i = 0; i < 3; i++) {
+        rateLimiter.checkLimit(key);
+      }
+      
+      // Advance time by 30 seconds
+      vi.setSystemTime(now + 30000);
+      
+      // Make 2 more requests (should reach limit)
+      for (let i = 0; i < 2; i++) {
+        rateLimiter.checkLimit(key);
+      }
+      
+      // Should be at limit
+      let result = rateLimiter.checkLimit(key);
+      expect(result.allowed).toBe(false);
+      
+      // Advance time by 31 seconds (first requests expire)
+      vi.setSystemTime(now + 61000);
+      
+      // Should allow new requests
+      result = rateLimiter.checkLimit(key);
+      expect(result.allowed).toBe(true);
+      expect(result.remaining).toBe(2); // 2 requests still in window, 3 allowed now
+    });
+
+    it('should handle different keys independently', () => {
+      const key1 = 'key1';
+      const key2 = 'key2';
+      
+      // Exhaust limit for key1
+      for (let i = 0; i < 5; i++) {
+        rateLimiter.checkLimit(key1);
+      }
+      
+      // key2 should still have full limit
+      const result = rateLimiter.checkLimit(key2);
+      expect(result.allowed).toBe(true);
+      expect(result.remaining).toBe(4);
+    });
+
+    it('should provide correct resetAt time', () => {
+      const key = 'test-key';
+      const now = Date.now();
+      
+      const firstResult = rateLimiter.checkLimit(key);
+      expect(firstResult.resetAt).toBeGreaterThan(now);
+      expect(firstResult.resetAt).toBeLessThanOrEqual(now + 60000);
+      
+      // Exhaust limit
+      for (let i = 0; i < 4; i++) {
+        rateLimiter.checkLimit(key);
+      }
+      
+      const deniedResult = rateLimiter.checkLimit(key);
+      expect(deniedResult.allowed).toBe(false);
+      expect(deniedResult.resetAt).toBe(firstResult.resetAt);
+    });
+  });
+
+  describe('reset', () => {
+    it('should reset limit for specific key', () => {
+      const key = 'test-key';
+      
+      // Exhaust limit
+      for (let i = 0; i < 5; i++) {
+        rateLimiter.checkLimit(key);
+      }
+      
+      // Should be denied
+      let result = rateLimiter.checkLimit(key);
+      expect(result.allowed).toBe(false);
+      
+      // Reset the key
+      rateLimiter.reset(key);
+      
+      // Should allow requests again
+      result = rateLimiter.checkLimit(key);
+      expect(result.allowed).toBe(true);
+      expect(result.remaining).toBe(4);
+    });
+  });
+
+  describe('resetAll', () => {
+    it('should reset all keys', () => {
+      const keys = ['key1', 'key2', 'key3'];
+      
+      // Exhaust limits for all keys
+      keys.forEach(key => {
+        for (let i = 0; i < 5; i++) {
+          rateLimiter.checkLimit(key);
+        }
+      });
+      
+      // All should be denied
+      keys.forEach(key => {
+        const result = rateLimiter.checkLimit(key);
+        expect(result.allowed).toBe(false);
+      });
+      
+      // Reset all
+      rateLimiter.resetAll();
+      
+      // All should allow requests again
+      keys.forEach(key => {
+        const result = rateLimiter.checkLimit(key);
+        expect(result.allowed).toBe(true);
+        expect(result.remaining).toBe(4);
+      });
+    });
+  });
+
+  describe('cleanup', () => {
+    it('should clean up old windows periodically', () => {
+      const key = 'test-key';
+      const now = Date.now();
+      
+      // Make a request
+      rateLimiter.checkLimit(key);
+      
+      // Advance time beyond cleanup threshold (2x window)
+      vi.setSystemTime(now + (130 * CONFIG.MILLISECONDS_PER_SECOND)); // 130 seconds
+      
+      // Trigger cleanup
+      vi.runOnlyPendingTimers();
+      
+      // Should have fresh limit
+      const result = rateLimiter.checkLimit(key);
+      expect(result.allowed).toBe(true);
+      expect(result.remaining).toBe(4);
+    });
+  });
+
+  describe('default configuration', () => {
+    it('should use default config values', () => {
+      const defaultLimiter = new RateLimiterService();
+      const key = 'test-key';
+      
+      // Should use DEFAULT_RATE_LIMIT_REQUESTS
+      for (let i = 0; i < CONFIG.DEFAULT_RATE_LIMIT_REQUESTS; i++) {
+        const result = defaultLimiter.checkLimit(key);
+        expect(result.allowed).toBe(true);
+      }
+      
+      // Next should be denied
+      const result = defaultLimiter.checkLimit(key);
+      expect(result.allowed).toBe(false);
+    });
+  });
+});
\ No newline at end of file
diff --git a/src/services/rate-limiter.service.ts b/src/services/rate-limiter.service.ts
new file mode 100644
index 0000000..71d22f4
--- /dev/null
+++ b/src/services/rate-limiter.service.ts
@@ -0,0 +1,80 @@
+import { CONFIG } from '../constants/config-constants.js';
+
+interface RateLimitWindow {
+  requests: number[];
+  windowStart: number;
+}
+
+export class RateLimiterService {
+  private readonly windows = new Map<string, RateLimitWindow>();
+  private readonly defaultLimit: number;
+  private readonly defaultWindowSeconds: number;
+
+  constructor(
+    defaultLimit: number = CONFIG.DEFAULT_RATE_LIMIT_REQUESTS,
+    defaultWindowSeconds: number = CONFIG.DEFAULT_RATE_LIMIT_WINDOW_SECONDS
+  ) {
+    this.defaultLimit = defaultLimit;
+    this.defaultWindowSeconds = defaultWindowSeconds;
+    
+    // Cleanup old windows periodically
+    setInterval(() => this.cleanup(), CONFIG.RATE_LIMIT_CLEANUP_INTERVAL_MS);
+  }
+
+  checkLimit(
+    key: string,
+    limit: number = this.defaultLimit,
+    windowSeconds: number = this.defaultWindowSeconds
+  ): { allowed: boolean; remaining: number; resetAt: number } {
+    const now = Date.now();
+    const windowMs = windowSeconds * CONFIG.MILLISECONDS_PER_SECOND;
+    const windowStart = now - windowMs;
+
+    let window = this.windows.get(key);
+    
+    if (!window) {
+      window = { requests: [], windowStart };
+      this.windows.set(key, window);
+    }
+
+    // Remove old requests outside the window
+    window.requests = window.requests.filter(time => time > windowStart);
+
+    const remaining = limit - window.requests.length;
+    const resetAt = window.requests.length > 0 && window.requests[0] !== undefined
+      ? window.requests[0] + windowMs 
+      : now + windowMs;
+
+    if (remaining <= 0) {
+      return { allowed: false, remaining: 0, resetAt };
+    }
+
+    // Add current request
+    window.requests.push(now);
+    
+    return { allowed: true, remaining: remaining - 1, resetAt };
+  }
+
+  private cleanup(): void {
+    const now = Date.now();
+    const maxAge = this.defaultWindowSeconds * CONFIG.MILLISECONDS_PER_SECOND * CONFIG.RATE_LIMIT_WINDOW_MULTIPLIER;
+
+    for (const [key, window] of this.windows.entries()) {
+      const hasRecentRequests = window.requests.some(
+        time => time > now - maxAge
+      );
+      
+      if (!hasRecentRequests) {
+        this.windows.delete(key);
+      }
+    }
+  }
+
+  reset(key: string): void {
+    this.windows.delete(key);
+  }
+
+  resetAll(): void {
+    this.windows.clear();
+  }
+}
\ No newline at end of file
diff --git a/src/tools/use-secret-tool.test.ts b/src/tools/use-secret-tool.test.ts
new file mode 100644
index 0000000..d804338
--- /dev/null
+++ b/src/tools/use-secret-tool.test.ts
@@ -0,0 +1,983 @@
+import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
+import { UseSecretTool } from './use-secret-tool.js';
+import { SecretProvider } from '../interfaces/secret-provider.interface.js';
+import { SecretAccessor } from '../interfaces/secret-accessor.interface.js';
+import { PolicyProviderService } from '../services/policy-provider.service.js';
+import { RateLimiterService } from '../services/rate-limiter.service.js';
+import type { IActionExecutor } from '../interfaces/action-executor.interface.js';
+import { JsonlAuditService } from '../services/audit-service.js';
+import type { AuditService } from '../interfaces/audit.interface.js';
+import { TEXT } from '../constants/text-constants.js';
+import { CONFIG } from '../constants/config-constants.js';
+
+vi.mock('../services/audit-service.js');
+
+describe('UseSecretTool', () => {
+  let tool: UseSecretTool;
+  let mockSecretProvider: SecretProvider & SecretAccessor;
+  let mockPolicyProvider: PolicyProviderService;
+  let mockActionExecutor: IActionExecutor;
+  let mockAuditService: AuditService;
+  let mockRateLimiter: RateLimiterService;
+
+  beforeEach(() => {
+    mockSecretProvider = {
+      listSecretIds: vi.fn(),
+      getSecretInfo: vi.fn(),
+      isSecretAvailable: vi.fn(),
+      getSecretValue: vi.fn()
+    } as any;
+
+    mockPolicyProvider = new PolicyProviderService();
+    
+    mockActionExecutor = {
+      execute: vi.fn()
+    };
+
+    mockRateLimiter = {
+      checkLimit: vi.fn().mockReturnValue({ allowed: true, remaining: 99, resetAt: Date.now() + CONFIG.DEFAULT_RATE_LIMIT_WINDOW_SECONDS * CONFIG.MILLISECONDS_PER_SECOND }),
+      reset: vi.fn(),
+      resetAll: vi.fn()
+    } as any;
+    
+    tool = new UseSecretTool(
+      mockSecretProvider,
+      mockPolicyProvider,
+      mockActionExecutor,
+      mockRateLimiter
+    );
+
+    // Access mocked instances
+    mockAuditService = (JsonlAuditService as any).mock.instances[0];
+  });
+
+  afterEach(() => {
+    vi.clearAllMocks();
+  });
+
+  describe('getTool', () => {
+    it('should return tool definition with correct schema', () => {
+      const toolDef = tool.getTool();
+      
+      expect(toolDef.name).toBe(TEXT.TOOL_USE);
+      expect(toolDef.description).toBe(TEXT.TOOL_DESC_USE);
+      expect(toolDef.inputSchema).toEqual({
+        type: TEXT.SCHEMA_TYPE_OBJECT,
+        properties: {
+          secretId: {
+            type: TEXT.SCHEMA_TYPE_STRING,
+            description: TEXT.INPUT_DESC_USE_SECRET_ID
+          },
+          action: {
+            type: TEXT.SCHEMA_TYPE_OBJECT,
+            properties: {
+              type: {
+                type: TEXT.SCHEMA_TYPE_STRING,
+                enum: [TEXT.HTTP_METHOD_GET, TEXT.HTTP_METHOD_POST],
+                description: TEXT.INPUT_DESC_ACTION_TYPE
+              },
+              url: {
+                type: TEXT.SCHEMA_TYPE_STRING,
+                description: TEXT.INPUT_DESC_ACTION_URL
+              },
+              headers: {
+                type: TEXT.SCHEMA_TYPE_OBJECT,
+                description: TEXT.INPUT_DESC_ACTION_HEADERS,
+                additionalProperties: { type: TEXT.SCHEMA_TYPE_STRING }
+              },
+              body: {
+                type: TEXT.SCHEMA_TYPE_STRING,
+                description: TEXT.INPUT_DESC_ACTION_BODY
+              },
+              injectionType: {
+                type: TEXT.SCHEMA_TYPE_STRING,
+                enum: [TEXT.INJECTION_TYPE_BEARER, TEXT.INJECTION_TYPE_HEADER],
+                description: TEXT.INPUT_DESC_INJECTION_TYPE
+              }
+            },
+            required: ['type', 'url']
+          }
+        },
+        required: ['secretId', 'action']
+      });
+    });
+  });
+
+  describe('execute', () => {
+    it('should successfully execute allowed action', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: 'http_get',
+          url: 'https://api.example.com/data'
+        }
+      };
+
+      vi.mocked(mockSecretProvider.getSecretInfo).mockReturnValue({
+        secretId: 'TEST_API_KEY',
+        available: true,
+        description: 'Test API key'
+      });
+
+      vi.mocked(mockSecretProvider.getSecretValue).mockReturnValue('secret-value-123');
+
+      mockPolicyProvider.evaluate = vi.fn().mockReturnValue({
+        allowed: true
+      });
+
+      mockAuditService.write = vi.fn().mockResolvedValue(undefined);
+
+      vi.mocked(mockActionExecutor.execute).mockResolvedValue({
+        statusCode: 200,
+        statusText: 'OK',
+        headers: {},
+        body: JSON.stringify({ data: 'test' })
+      });
+
+      const result = await tool.execute(args);
+
+      expect(result).toEqual({
+        success: true,
+        result: {
+          statusCode: 200,
+          statusText: 'OK',
+          headers: {},
+          body: JSON.stringify({ data: 'test' })
+        }
+      });
+
+      expect(mockPolicyProvider.evaluate).toHaveBeenCalledWith(
+        'TEST_API_KEY',
+        'http_get',
+        'api.example.com'
+      );
+
+      expect(mockAuditService.write).toHaveBeenCalledWith({
+        secretId: 'TEST_API_KEY',
+        action: 'http_get',
+        domain: 'api.example.com',
+        timestamp: expect.any(String),
+        outcome: TEXT.AUDIT_OUTCOME_SUCCESS,
+        reason: TEXT.SUCCESS_REQUEST_COMPLETED
+      });
+
+      expect(mockActionExecutor.execute).toHaveBeenCalledWith({
+        method: TEXT.HTTP_VERB_GET,
+        url: 'https://api.example.com/data',
+        headers: undefined,
+        body: undefined,
+        secretValue: 'secret-value-123',
+        injectionType: 'bearer'
+      });
+    });
+
+    it('should deny action when policy evaluator denies', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: 'http_post',
+          url: 'https://forbidden.com/api',
+          body: '{"data": "test"}'
+        }
+      };
+
+      vi.mocked(mockSecretProvider.getSecretInfo).mockReturnValue({
+        secretId: 'TEST_API_KEY',
+        available: true,
+        description: 'Test API key'
+      });
+
+      mockPolicyProvider.evaluate = vi.fn().mockReturnValue({
+        allowed: false,
+        message: TEXT.ERROR_FORBIDDEN_DOMAIN
+      });
+
+      mockAuditService.write = vi.fn().mockResolvedValue(undefined);
+
+      const result = await tool.execute(args);
+
+      expect(result.success).toBe(false);
+      expect(result.error).toBe(TEXT.ERROR_FORBIDDEN_DOMAIN);
+      expect(result.code).toBeDefined();
+
+      expect(mockAuditService.write).toHaveBeenCalledWith({
+        secretId: 'TEST_API_KEY',
+        action: 'http_post',
+        domain: 'forbidden.com',
+        timestamp: expect.any(String),
+        outcome: TEXT.AUDIT_OUTCOME_DENIED,
+        reason: TEXT.ERROR_FORBIDDEN_DOMAIN
+      });
+
+      expect(mockActionExecutor.execute).not.toHaveBeenCalled();
+    });
+
+    it('should return error for unknown secret', async () => {
+      const args = {
+        secretId: 'UNKNOWN_SECRET',
+        action: {
+          type: 'http_get',
+          url: 'https://api.example.com/data'
+        }
+      };
+
+      vi.mocked(mockSecretProvider.getSecretInfo).mockReturnValue(undefined);
+
+      const result = await tool.execute(args);
+
+      expect(result.success).toBe(false);
+      expect(result.error).toBe(TEXT.ERROR_UNKNOWN_SECRET);
+      expect(result.code).toBe('unknown_secret');
+    });
+
+    it('should return error for unavailable secret', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: 'http_get',
+          url: 'https://api.example.com/data'
+        }
+      };
+
+      vi.mocked(mockSecretProvider.getSecretInfo).mockReturnValue({
+        secretId: 'TEST_API_KEY',
+        available: false,
+        description: 'Test API key'
+      });
+
+      const result = await tool.execute(args);
+
+      expect(result.success).toBe(false);
+      expect(result.error).toBe(TEXT.ERROR_UNKNOWN_SECRET);
+      expect(result.code).toBe('unknown_secret');
+    });
+
+    it('should return error for invalid arguments', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY'
+        // Missing action
+      };
+
+      const result = await tool.execute(args);
+
+      expect(result.success).toBe(false);
+      expect(result.error).toBe(TEXT.ERROR_INVALID_REQUEST);
+      expect(result.code).toBe('invalid_request');
+    });
+
+    it('should return error for invalid URL', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: 'http_get',
+          url: 'not-a-valid-url'
+        }
+      };
+
+      const result = await tool.execute(args);
+
+      expect(result.success).toBe(false);
+      expect(result.error).toBe(TEXT.ERROR_INVALID_URL);
+      expect(result.code).toBe('invalid_url');
+    });
+
+    it('should handle POST request with headers and body', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: 'http_post',
+          url: 'https://api.example.com/submit',
+          headers: {
+            'Content-Type': 'application/json',
+            'X-Custom-Header': 'custom-value'
+          },
+          body: '{"key": "value"}'
+        }
+      };
+
+      vi.mocked(mockSecretProvider.getSecretInfo).mockReturnValue({
+        secretId: 'TEST_API_KEY',
+        available: true,
+        description: 'Test API key'
+      });
+
+      vi.mocked(mockSecretProvider.getSecretValue).mockReturnValue('secret-value-123');
+
+      mockPolicyProvider.evaluate = vi.fn().mockReturnValue({
+        allowed: true
+      });
+
+      mockAuditService.write = vi.fn().mockResolvedValue(undefined);
+
+      vi.mocked(mockActionExecutor.execute).mockResolvedValue({
+        statusCode: 201,
+        statusText: 'Created',
+        headers: {},
+        body: JSON.stringify({ success: true })
+      });
+
+      const result = await tool.execute(args);
+
+      expect(result).toEqual({
+        success: true,
+        result: {
+          statusCode: 201,
+          statusText: 'Created',
+          headers: {},
+          body: JSON.stringify({ success: true })
+        }
+      });
+
+      expect(mockActionExecutor.execute).toHaveBeenCalledWith({
+        method: TEXT.HTTP_VERB_POST,
+        url: 'https://api.example.com/submit',
+        headers: {
+          'Content-Type': 'application/json',
+          'X-Custom-Header': 'custom-value'
+        },
+        body: '{"key": "value"}',
+        secretValue: 'secret-value-123',
+        injectionType: 'bearer'
+      });
+    });
+
+    it('should trim URL before validation', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: 'http_get',
+          url: '  https://api.example.com/data  '  // URL with spaces
+        }
+      };
+
+      vi.mocked(mockSecretProvider.getSecretInfo).mockReturnValue({
+        secretId: 'TEST_API_KEY',
+        available: true,
+        description: 'Test'
+      });
+
+      vi.mocked(mockSecretProvider.getSecretValue).mockReturnValue('secret');
+
+      mockPolicyProvider.evaluate = vi.fn().mockReturnValue({
+        allowed: true
+      });
+
+      mockAuditService.write = vi.fn().mockResolvedValue(undefined);
+
+      vi.mocked(mockActionExecutor.execute).mockResolvedValue({
+        statusCode: 200,
+        statusText: 'OK',
+        headers: {},
+        body: '{}'
+      });
+
+      const result = await tool.execute(args);
+
+      expect(result.success).toBe(true);
+      expect(mockActionExecutor.execute).toHaveBeenCalledWith(
+        expect.objectContaining({
+          url: 'https://api.example.com/data'  // Trimmed URL
+        })
+      );
+    });
+  });
+
+  describe('rate limiting', () => {
+    it('should deny request when rate limit exceeded', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: 'http_get',
+          url: 'https://api.example.com/data'
+        }
+      };
+
+      vi.mocked(mockRateLimiter.checkLimit).mockReturnValue({
+        allowed: false,
+        remaining: 0,
+        resetAt: Date.now() + CONFIG.DEFAULT_RATE_LIMIT_WINDOW_SECONDS * CONFIG.MILLISECONDS_PER_SECOND
+      });
+
+      mockAuditService.write = vi.fn().mockResolvedValue(undefined);
+
+      const result = await tool.execute(args);
+
+      expect(result.success).toBe(false);
+      expect(result.error).toBe(TEXT.ERROR_RATE_LIMITED);
+      expect(result.code).toBe('rate_limited');
+
+      expect(mockAuditService.write).toHaveBeenCalledWith({
+        secretId: 'TEST_API_KEY',
+        action: 'http_get',
+        domain: 'api.example.com',
+        timestamp: expect.any(String),
+        outcome: TEXT.AUDIT_OUTCOME_DENIED,
+        reason: TEXT.ERROR_RATE_LIMITED
+      });
+    });
+
+    it('should check rate limit with correct key', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: 'http_get',
+          url: 'https://api.example.com/data'
+        }
+      };
+
+      vi.mocked(mockSecretProvider.getSecretInfo).mockReturnValue({
+        secretId: 'TEST_API_KEY',
+        available: true,
+        description: 'Test API key'
+      });
+
+      await tool.execute(args);
+
+      expect(mockRateLimiter.checkLimit).toHaveBeenCalledWith('TEST_API_KEY:api.example.com');
+    });
+  });
+
+  describe('input validation', () => {
+    it('should trim input strings', async () => {
+      const args = {
+        secretId: '  TEST_API_KEY  ',
+        action: {
+          type: 'http_get',
+          url: '  https://api.example.com/data  ',
+          headers: {
+            '  X-Custom  ': '  value  '
+          }
+        }
+      };
+
+      vi.mocked(mockSecretProvider.getSecretInfo).mockReturnValue({
+        secretId: 'TEST_API_KEY',
+        available: true,
+        description: 'Test'
+      });
+
+      vi.mocked(mockSecretProvider.getSecretValue).mockReturnValue('secret');
+
+      mockPolicyProvider.evaluate = vi.fn().mockReturnValue({
+        allowed: true
+      });
+
+      mockAuditService.write = vi.fn().mockResolvedValue(undefined);
+
+      vi.mocked(mockActionExecutor.execute).mockResolvedValue({
+        statusCode: 200,
+        statusText: 'OK',
+        headers: {},
+        body: '{}'
+      });
+
+      await tool.execute(args);
+
+      // Check that trimmed values were used
+      expect(mockSecretProvider.getSecretInfo).toHaveBeenCalledWith('TEST_API_KEY');
+      expect(mockActionExecutor.execute).toHaveBeenCalledWith(
+        expect.objectContaining({
+          url: 'https://api.example.com/data',
+          headers: {
+            'X-Custom': 'value'
+          }
+        })
+      );
+    });
+
+    it('should audit invalid URL', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: 'http_get',
+          url: 'not-a-valid-url'
+        }
+      };
+
+      mockAuditService.write = vi.fn().mockResolvedValue(undefined);
+
+      const result = await tool.execute(args);
+
+      expect(result.success).toBe(false);
+      expect(result.error).toBe(TEXT.ERROR_INVALID_URL);
+      expect(result.code).toBe('invalid_url');
+    });
+
+    it('should support injection type parameter', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: 'http_post',
+          url: 'https://api.example.com/data',
+          injectionType: 'header'
+        }
+      };
+
+      vi.mocked(mockSecretProvider.getSecretInfo).mockReturnValue({
+        secretId: 'TEST_API_KEY',
+        available: true,
+        description: 'Test'
+      });
+
+      vi.mocked(mockSecretProvider.getSecretValue).mockReturnValue('secret');
+
+      mockPolicyProvider.evaluate = vi.fn().mockReturnValue({
+        allowed: true
+      });
+
+      mockAuditService.write = vi.fn().mockResolvedValue(undefined);
+
+      vi.mocked(mockActionExecutor.execute).mockResolvedValue({
+        statusCode: 200,
+        statusText: 'OK',
+        headers: {},
+        body: '{}'
+      });
+
+      await tool.execute(args);
+
+      expect(mockActionExecutor.execute).toHaveBeenCalledWith(
+        expect.objectContaining({
+          injectionType: 'header'
+        })
+      );
+    });
+
+    it('should handle invalid action type with specific error', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: 'DELETE', // Invalid method
+          url: 'https://api.example.com/data'
+        }
+      };
+
+      mockAuditService.write = vi.fn().mockResolvedValue(undefined);
+
+      const result = await tool.execute(args);
+
+      expect(result.success).toBe(false);
+      expect(result.error).toBe(TEXT.ERROR_INVALID_METHOD);
+      expect(result.code).toBe(CONFIG.ERROR_CODE_INVALID_METHOD);
+    });
+
+    it('should handle invalid injection type with specific error', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: 'http_get',
+          url: 'https://api.example.com/data',
+          injectionType: 'custom' // Invalid injection type
+        }
+      };
+
+      mockAuditService.write = vi.fn().mockResolvedValue(undefined);
+
+      const result = await tool.execute(args);
+
+      expect(result.success).toBe(false);
+      expect(result.error).toBe(TEXT.ERROR_INVALID_INJECTION_TYPE);
+      expect(result.code).toBe(CONFIG.ERROR_CODE_INVALID_INJECTION_TYPE);
+    });
+
+    it('should trim action.type before enum validation', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: '  http_get  ', // Action type with spaces
+          url: 'https://api.example.com/data'
+        }
+      };
+
+      vi.mocked(mockSecretProvider.getSecretInfo).mockReturnValue({
+        secretId: 'TEST_API_KEY',
+        available: true,
+        description: 'Test'
+      });
+
+      vi.mocked(mockSecretProvider.getSecretValue).mockReturnValue('secret');
+
+      mockPolicyProvider.evaluate = vi.fn().mockReturnValue({
+        allowed: true
+      });
+
+      mockAuditService.write = vi.fn().mockResolvedValue(undefined);
+
+      vi.mocked(mockActionExecutor.execute).mockResolvedValue({
+        statusCode: 200,
+        statusText: 'OK',
+        headers: {},
+        body: '{}'
+      });
+
+      const result = await tool.execute(args);
+
+      expect(result.success).toBe(true);
+      
+      // Verify that the trimmed value was used in execution
+      expect(mockActionExecutor.execute).toHaveBeenCalledWith(
+        expect.objectContaining({
+          method: TEXT.HTTP_VERB_GET
+        })
+      );
+    });
+
+    it('should trim injectionType before enum validation', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: 'http_get',
+          url: 'https://api.example.com/data',
+          injectionType: '  header  ' // Injection type with spaces
+        }
+      };
+
+      vi.mocked(mockSecretProvider.getSecretInfo).mockReturnValue({
+        secretId: 'TEST_API_KEY',
+        available: true,
+        description: 'Test'
+      });
+
+      vi.mocked(mockSecretProvider.getSecretValue).mockReturnValue('secret');
+
+      mockPolicyProvider.evaluate = vi.fn().mockReturnValue({
+        allowed: true
+      });
+
+      mockAuditService.write = vi.fn().mockResolvedValue(undefined);
+
+      vi.mocked(mockActionExecutor.execute).mockResolvedValue({
+        statusCode: 200,
+        statusText: 'OK',
+        headers: {},
+        body: '{}'
+      });
+
+      const result = await tool.execute(args);
+
+      expect(result.success).toBe(true);
+      
+      // Verify that the trimmed value was used in execution
+      expect(mockActionExecutor.execute).toHaveBeenCalledWith(
+        expect.objectContaining({
+          injectionType: 'header'
+        })
+      );
+    });
+  });
+
+  describe('audit coverage', () => {
+    it('should audit completely invalid request with fallback values', async () => {
+      const args = {}; // Missing both secretId and action
+
+      mockAuditService.write = vi.fn().mockResolvedValue(undefined);
+
+      const result = await tool.execute(args);
+
+      expect(result.success).toBe(false);
+      expect(result.error).toBe(TEXT.ERROR_INVALID_REQUEST);
+      expect(result.code).toBe('invalid_request');
+
+      // Should have written audit with fallback values
+      expect(mockAuditService.write).toHaveBeenCalledWith({
+        secretId: 'unknown',
+        action: 'unknown',
+        domain: 'unknown',
+        timestamp: expect.any(String),
+        outcome: TEXT.AUDIT_OUTCOME_DENIED,
+        reason: TEXT.ERROR_INVALID_REQUEST
+      });
+    });
+
+    it('should audit when policyProvider.evaluate throws', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: 'http_get',
+          url: 'https://api.example.com/data'
+        }
+      };
+
+      vi.mocked(mockSecretProvider.getSecretInfo).mockReturnValue({
+        secretId: 'TEST_API_KEY',
+        available: true,
+        description: 'Test API key'
+      });
+
+      const evaluationError = new Error('Policy evaluation failed');
+      mockPolicyProvider.evaluate = vi.fn().mockImplementation(() => {
+        throw evaluationError;
+      });
+
+      mockAuditService.write = vi.fn().mockResolvedValue(undefined);
+
+      const result = await tool.execute(args);
+
+      expect(result.success).toBe(false);
+      expect(result.error).toBe(TEXT.ERROR_EXECUTION_FAILED);
+      expect(result.code).toBe('execution_failed');
+
+      // Should have written audit for the policy evaluation error
+      expect(mockAuditService.write).toHaveBeenCalledWith({
+        secretId: 'TEST_API_KEY',
+        action: 'http_get',
+        domain: 'api.example.com',
+        timestamp: expect.any(String),
+        outcome: TEXT.AUDIT_OUTCOME_ERROR,
+        reason: 'Policy evaluation failed'
+      });
+    });
+
+    it('should reject empty header names after trimming', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: 'http_get',
+          url: 'https://api.example.com/data',
+          headers: {
+            '   ': 'value'  // Header name that's only whitespace
+          }
+        }
+      };
+
+      mockAuditService.write = vi.fn().mockResolvedValue(undefined);
+
+      const result = await tool.execute(args);
+
+      expect(result.success).toBe(false);
+      expect(result.error).toBe(TEXT.ERROR_EMPTY_HEADER_NAME);
+      expect(result.code).toBe('invalid_headers');
+
+      // Should have written audit for invalid request
+      expect(mockAuditService.write).toHaveBeenCalledWith({
+        secretId: 'TEST_API_KEY',
+        action: 'http_get',
+        domain: 'unknown',
+        timestamp: expect.any(String),
+        outcome: TEXT.AUDIT_OUTCOME_DENIED,
+        reason: TEXT.ERROR_INVALID_REQUEST
+      });
+    });
+
+
+    it('should audit successful execution', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: 'http_get',
+          url: 'https://api.example.com/data'
+        }
+      };
+
+      vi.mocked(mockSecretProvider.getSecretInfo).mockReturnValue({
+        secretId: 'TEST_API_KEY',
+        available: true,
+        description: 'Test'
+      });
+
+      vi.mocked(mockSecretProvider.getSecretValue).mockReturnValue('secret');
+
+      mockPolicyProvider.evaluate = vi.fn().mockReturnValue({
+        allowed: true
+      });
+
+      mockAuditService.write = vi.fn().mockResolvedValue(undefined);
+
+      vi.mocked(mockActionExecutor.execute).mockResolvedValue({
+        statusCode: 200,
+        statusText: 'OK',
+        headers: {},
+        body: '{}'
+      });
+
+      await tool.execute(args);
+
+      expect(mockAuditService.write).toHaveBeenCalledWith({
+        secretId: 'TEST_API_KEY',
+        action: 'http_get',
+        domain: 'api.example.com',
+        timestamp: expect.any(String),
+        outcome: TEXT.AUDIT_OUTCOME_SUCCESS,
+        reason: TEXT.SUCCESS_REQUEST_COMPLETED
+      });
+    });
+
+    it('should audit executor errors', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: 'http_get',
+          url: 'https://api.example.com/data'
+        }
+      };
+
+      vi.mocked(mockSecretProvider.getSecretInfo).mockReturnValue({
+        secretId: 'TEST_API_KEY',
+        available: true,
+        description: 'Test'
+      });
+
+      vi.mocked(mockSecretProvider.getSecretValue).mockReturnValue('secret');
+
+      mockPolicyProvider.evaluate = vi.fn().mockReturnValue({
+        allowed: true
+      });
+
+      mockAuditService.write = vi.fn().mockResolvedValue(undefined);
+
+      const executorError = new Error('Network timeout');
+      vi.mocked(mockActionExecutor.execute).mockRejectedValue(executorError);
+
+      const result = await tool.execute(args);
+
+      expect(result.success).toBe(false);
+      
+      // Should have written audit for the executor error
+      expect(mockAuditService.write).toHaveBeenCalledWith({
+        secretId: 'TEST_API_KEY',
+        action: 'http_get',
+        domain: 'api.example.com',
+        timestamp: expect.any(String),
+        outcome: TEXT.AUDIT_OUTCOME_ERROR,
+        reason: 'Network timeout'
+      });
+    });
+
+    it('should audit missing secret value', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: 'http_get',
+          url: 'https://api.example.com/data'
+        }
+      };
+
+      vi.mocked(mockSecretProvider.getSecretInfo).mockReturnValue({
+        secretId: 'TEST_API_KEY',
+        available: true,
+        description: 'Test'
+      });
+
+      vi.mocked(mockSecretProvider.getSecretValue).mockReturnValue(undefined);
+
+      mockPolicyProvider.evaluate = vi.fn().mockReturnValue({
+        allowed: true
+      });
+
+      mockAuditService.write = vi.fn().mockResolvedValue(undefined);
+
+      const result = await tool.execute(args);
+
+      expect(result.success).toBe(false);
+      expect(result.error).toBe(TEXT.ERROR_MISSING_ENV);
+      expect(result.code).toBe('missing_env');
+
+      expect(mockAuditService.write).toHaveBeenCalledWith({
+        secretId: 'TEST_API_KEY',
+        action: 'http_get',
+        domain: 'api.example.com',
+        timestamp: expect.any(String),
+        outcome: TEXT.AUDIT_OUTCOME_ERROR,
+        reason: TEXT.ERROR_MISSING_ENV
+      });
+    });
+
+    it('should return execution_failed code for unexpected errors', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: 'http_get',
+          url: 'https://api.example.com/data'
+        }
+      };
+
+      vi.mocked(mockSecretProvider.getSecretInfo).mockImplementation(() => {
+        throw new Error('Unexpected error');
+      });
+
+      const result = await tool.execute(args);
+
+      expect(result.success).toBe(false);
+      expect(result.error).toBe('Unexpected error');
+      expect(result.code).toBe('execution_failed');
+    });
+
+    it('should audit unexpected errors in catch-all path', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: 'http_get',
+          url: 'https://api.example.com/data'
+        }
+      };
+
+      // Mock to throw non-ToolError, non-ZodError
+      vi.mocked(mockSecretProvider.getSecretInfo).mockImplementation(() => {
+        throw new Error('Unexpected database error');
+      });
+
+      mockAuditService.write = vi.fn().mockResolvedValue(undefined);
+
+      const result = await tool.execute(args);
+
+      expect(result.success).toBe(false);
+      expect(result.error).toBe('Unexpected database error');
+      expect(result.code).toBe('execution_failed');
+
+      // Verify audit entry was created with error outcome
+      expect(mockAuditService.write).toHaveBeenCalledWith({
+        secretId: 'TEST_API_KEY',
+        action: 'http_get',
+        domain: 'api.example.com',
+        timestamp: expect.any(String),
+        outcome: TEXT.AUDIT_OUTCOME_ERROR,
+        reason: TEXT.ERROR_EXECUTION_FAILED
+      });
+    });
+
+    it('should not write duplicate audit when executor throws error', async () => {
+      const args = {
+        secretId: 'TEST_API_KEY',
+        action: {
+          type: 'http_get',
+          url: 'https://api.example.com/data'
+        }
+      };
+
+      vi.mocked(mockSecretProvider.getSecretInfo).mockReturnValue({
+        secretId: 'TEST_API_KEY',
+        available: true,
+        description: 'Test API key'
+      });
+
+      vi.mocked(mockSecretProvider.getSecretValue).mockReturnValue('secret');
+
+      mockPolicyProvider.evaluate = vi.fn().mockReturnValue({
+        allowed: true
+      });
+
+      // Make executor throw an error
+      const executorError = new Error('Network request failed');
+      vi.mocked(mockActionExecutor.execute).mockRejectedValue(executorError);
+
+      mockAuditService.write = vi.fn().mockResolvedValue(undefined);
+
+      const result = await tool.execute(args);
+
+      expect(result.success).toBe(false);
+      expect(result.error).toBe('Network request failed');
+      expect(result.code).toBe('execution_failed');
+
+      // Should only write one audit entry (from executeSecretAction, not from handleExecutionError)
+      expect(mockAuditService.write).toHaveBeenCalledTimes(1);
+      expect(mockAuditService.write).toHaveBeenCalledWith({
+        secretId: 'TEST_API_KEY',
+        action: 'http_get',
+        domain: 'api.example.com',
+        timestamp: expect.any(String),
+        outcome: TEXT.AUDIT_OUTCOME_ERROR,
+        reason: 'Network request failed'
+      });
+    });
+  });
+});
\ No newline at end of file
diff --git a/src/tools/use-secret-tool.ts b/src/tools/use-secret-tool.ts
new file mode 100644
index 0000000..82d1278
--- /dev/null
+++ b/src/tools/use-secret-tool.ts
@@ -0,0 +1,428 @@
+import { Tool } from '@modelcontextprotocol/sdk/types.js';
+import { SecretProvider } from '../interfaces/secret-provider.interface.js';
+import type { IActionExecutor } from '../interfaces/action-executor.interface.js';
+import { SecretAccessor } from '../interfaces/secret-accessor.interface.js';
+import { JsonlAuditService } from '../services/audit-service.js';
+import { PolicyProviderService } from '../services/policy-provider.service.js';
+import { RateLimiterService } from '../services/rate-limiter.service.js';
+import type { AuditService } from '../interfaces/audit.interface.js';
+import { TEXT } from '../constants/text-constants.js';
+import { CONFIG } from '../constants/config-constants.js';
+import { ToolError } from '../utils/errors.js';
+import { writeError } from '../utils/logging.js';
+import { z } from 'zod';
+
+const UseSecretSchema = z.object({
+  secretId: z.string().min(1).transform(s => s.trim()),
+  action: z.object({
+    type: z.string().transform(s => s.trim()).pipe(z.enum([TEXT.HTTP_METHOD_GET, TEXT.HTTP_METHOD_POST])),
+    url: z.string().transform(s => s.trim()).refine(
+      (val) => {
+        try {
+          new URL(val);
+          return true;
+        } catch {
+          return false;
+        }
+      },
+      { message: TEXT.ERROR_INVALID_URL }
+    ),
+    headers: z.record(z.string()).optional().transform(h => {
+      if (!h) return undefined;
+      const trimmed: Record<string, string> = {};
+      for (const [key, value] of Object.entries(h)) {
+        const trimmedKey = key.trim();
+        if (trimmedKey === '') {
+          throw new z.ZodError([
+            {
+              code: z.ZodIssueCode.custom,
+              message: TEXT.ERROR_EMPTY_HEADER_NAME,
+              path: ['headers', key]
+            }
+          ]);
+        }
+        trimmed[trimmedKey] = value.trim();
+      }
+      return trimmed;
+    }),
+    body: z.string().optional().transform(s => s?.trim()),
+    injectionType: z.string().optional().transform(s => s?.trim()).pipe(z.enum([TEXT.INJECTION_TYPE_BEARER, TEXT.INJECTION_TYPE_HEADER]))
+      .default(TEXT.INJECTION_TYPE_BEARER)
+  })
+});
+
+export interface UseSecretArgs {
+  readonly secretId: string;
+  readonly action: {
+    readonly type: typeof TEXT.HTTP_METHOD_GET | typeof TEXT.HTTP_METHOD_POST;
+    readonly url: string;
+    readonly headers?: Record<string, string>;
+    readonly body?: string;
+    readonly injectionType?: typeof TEXT.INJECTION_TYPE_BEARER | typeof TEXT.INJECTION_TYPE_HEADER;
+  };
+}
+
+export interface UseSecretResponse {
+  readonly success: boolean;
+  readonly result?: unknown;
+  readonly error?: string;
+  readonly code?: string;
+}
+
+interface AuditContext {
+  secretId: string;
+  action: string;
+  domain: string;
+}
+
+interface ValidatedRequest {
+  secretId: string;
+  action: UseSecretArgs['action'];
+  domain: string;
+}
+
+class AuditedError extends Error {
+  constructor(message: string, public readonly originalError: unknown) {
+    super(message);
+    this.name = 'AuditedError';
+  }
+}
+
+export class UseSecretTool {
+  private readonly tool: Tool;
+  private readonly auditService: AuditService;
+  private readonly rateLimiter: RateLimiterService;
+
+  constructor(
+    private readonly secretProvider: SecretProvider & SecretAccessor,
+    private readonly policyProvider: PolicyProviderService,
+    private readonly actionExecutor: IActionExecutor,
+    rateLimiter?: RateLimiterService
+  ) {
+    this.auditService = new JsonlAuditService();
+    this.rateLimiter = rateLimiter || new RateLimiterService();
+    
+    this.tool = {
+      name: TEXT.TOOL_USE,
+      description: TEXT.TOOL_DESC_USE,
+      inputSchema: {
+        type: TEXT.SCHEMA_TYPE_OBJECT,
+        properties: {
+          secretId: {
+            type: TEXT.SCHEMA_TYPE_STRING,
+            description: TEXT.INPUT_DESC_USE_SECRET_ID
+          },
+          action: {
+            type: TEXT.SCHEMA_TYPE_OBJECT,
+            properties: {
+              type: {
+                type: TEXT.SCHEMA_TYPE_STRING,
+                enum: [TEXT.HTTP_METHOD_GET, TEXT.HTTP_METHOD_POST],
+                description: TEXT.INPUT_DESC_ACTION_TYPE
+              },
+              url: {
+                type: TEXT.SCHEMA_TYPE_STRING,
+                description: TEXT.INPUT_DESC_ACTION_URL
+              },
+              headers: {
+                type: TEXT.SCHEMA_TYPE_OBJECT,
+                description: TEXT.INPUT_DESC_ACTION_HEADERS,
+                additionalProperties: { type: TEXT.SCHEMA_TYPE_STRING }
+              },
+              body: {
+                type: TEXT.SCHEMA_TYPE_STRING,
+                description: TEXT.INPUT_DESC_ACTION_BODY
+              },
+              injectionType: {
+                type: TEXT.SCHEMA_TYPE_STRING,
+                enum: [TEXT.INJECTION_TYPE_BEARER, TEXT.INJECTION_TYPE_HEADER],
+                description: TEXT.INPUT_DESC_INJECTION_TYPE
+              }
+            },
+            required: ['type', 'url']
+          }
+        },
+        required: ['secretId', 'action']
+      }
+    };
+  }
+
+  getTool(): Tool {
+    return this.tool;
+  }
+
+  /**
+   * Helper method to write audit entries with consistent formatting
+   */
+  private async auditRequest(
+    context: Partial<AuditContext>,
+    outcome: typeof TEXT.AUDIT_OUTCOME_SUCCESS | typeof TEXT.AUDIT_OUTCOME_DENIED | typeof TEXT.AUDIT_OUTCOME_ERROR,
+    reason: string
+  ): Promise<void> {
+    await this.auditService.write({
+      secretId: context.secretId || TEXT.FIELD_VALUE_UNKNOWN,
+      action: context.action || TEXT.FIELD_VALUE_UNKNOWN,
+      domain: context.domain || TEXT.FIELD_VALUE_UNKNOWN,
+      timestamp: new Date().toISOString(),
+      outcome,
+      reason
+    });
+  }
+
+  /**
+   * Validates input arguments and extracts request parameters
+   */
+  private async validateAndExtractRequest(args: unknown): Promise<ValidatedRequest> {
+    try {
+      const validatedArgs = UseSecretSchema.parse(args) as UseSecretArgs;
+      const url = new URL(validatedArgs.action.url);
+      
+      return {
+        secretId: validatedArgs.secretId,
+        action: validatedArgs.action,
+        domain: url.hostname
+      };
+    } catch (validationError) {
+      const rawArgs = args as any;
+      await this.auditRequest(
+        {
+          secretId: rawArgs?.secretId,
+          action: rawArgs?.action?.type,
+          domain: undefined
+        },
+        TEXT.AUDIT_OUTCOME_DENIED,
+        TEXT.ERROR_INVALID_REQUEST
+      );
+      throw validationError;
+    }
+  }
+
+  /**
+   * Enforces rate limiting for the request
+   */
+  private async enforceRateLimit(secretId: string, domain: string, action?: string): Promise<void> {
+    const rateLimitKey = `${secretId}:${domain}`;
+    const rateCheck = this.rateLimiter.checkLimit(rateLimitKey);
+    
+    if (!rateCheck.allowed) {
+      await this.auditRequest(
+        { secretId, action, domain },
+        TEXT.AUDIT_OUTCOME_DENIED,
+        TEXT.ERROR_RATE_LIMITED
+      );
+      
+      writeError(TEXT.ERROR_RATE_LIMITED, {
+        level: 'WARN',
+        code: CONFIG.ERROR_CODE_RATE_LIMITED,
+        secretId,
+        domain
+      });
+      
+      throw new ToolError(TEXT.ERROR_RATE_LIMITED, CONFIG.ERROR_CODE_RATE_LIMITED);
+    }
+  }
+
+  /**
+   * Verifies that the secret exists and is available
+   */
+  private async verifySecretExists(secretId: string, action: string, domain: string): Promise<void> {
+    const secretInfo = this.secretProvider.getSecretInfo(secretId);
+    
+    if (!secretInfo || !secretInfo.available) {
+      await this.auditRequest(
+        { secretId, action, domain },
+        TEXT.AUDIT_OUTCOME_DENIED,
+        TEXT.ERROR_UNKNOWN_SECRET
+      );
+      
+      throw new ToolError(
+        TEXT.ERROR_UNKNOWN_SECRET,
+        CONFIG.ERROR_CODE_UNKNOWN_SECRET
+      );
+    }
+  }
+
+  /**
+   * Evaluates access policy for the request
+   */
+  private async evaluateAccessPolicy(secretId: string, action: string, domain: string): Promise<void> {
+    try {
+      const accessDecision = this.policyProvider.evaluate(secretId, action, domain);
+      
+      if (!accessDecision.allowed) {
+        await this.auditRequest(
+          { secretId, action, domain },
+          TEXT.AUDIT_OUTCOME_DENIED,
+          accessDecision.message || TEXT.ERROR_FORBIDDEN_ACTION
+        );
+        
+        const errorCode = accessDecision.code || CONFIG.ERROR_CODE_FORBIDDEN_ACTION;
+        const errorMessage = accessDecision.message || TEXT.ERROR_FORBIDDEN_ACTION;
+        throw new ToolError(errorMessage, errorCode);
+      }
+    } catch (policyError) {
+      // If it's already a ToolError from the denied case above, rethrow it
+      if (policyError instanceof ToolError) {
+        throw policyError;
+      }
+      
+      // For unexpected policy evaluation errors
+      await this.auditRequest(
+        { secretId, action, domain },
+        TEXT.AUDIT_OUTCOME_ERROR,
+        policyError instanceof Error ? policyError.message : TEXT.ERROR_EXECUTION_FAILED
+      );
+      throw new ToolError(TEXT.ERROR_EXECUTION_FAILED, CONFIG.ERROR_CODE_EXECUTION_FAILED);
+    }
+  }
+
+  /**
+   * Retrieves the secret value
+   */
+  private async retrieveSecretValue(secretId: string, action: string, domain: string): Promise<string> {
+    const secretValue = this.secretProvider.getSecretValue(secretId);
+    
+    if (!secretValue) {
+      await this.auditRequest(
+        { secretId, action, domain },
+        TEXT.AUDIT_OUTCOME_ERROR,
+        TEXT.ERROR_MISSING_ENV
+      );
+      
+      throw new ToolError(TEXT.ERROR_MISSING_ENV, CONFIG.ERROR_CODE_MISSING_ENV);
+    }
+    
+    return secretValue;
+  }
+
+  /**
+   * Executes the secret action and handles success/error auditing
+   */
+  private async executeSecretAction(
+    action: UseSecretArgs['action'],
+    secretValue: string,
+    context: AuditContext
+  ): Promise<unknown> {
+    try {
+      const result = await this.actionExecutor.execute({
+        method: action.type === TEXT.HTTP_METHOD_GET ? TEXT.HTTP_VERB_GET : TEXT.HTTP_VERB_POST,
+        url: action.url,
+        headers: action.headers,
+        body: action.body,
+        secretValue,
+        injectionType: action.injectionType || TEXT.INJECTION_TYPE_BEARER
+      });
+      
+      await this.auditRequest(context, TEXT.AUDIT_OUTCOME_SUCCESS, TEXT.SUCCESS_REQUEST_COMPLETED);
+      return result;
+    } catch (executorError) {
+      await this.auditRequest(
+        context,
+        TEXT.AUDIT_OUTCOME_ERROR,
+        executorError instanceof Error ? executorError.message : TEXT.ERROR_NETWORK_ERROR
+      );
+      throw new AuditedError(
+        executorError instanceof Error ? executorError.message : TEXT.ERROR_NETWORK_ERROR,
+        executorError
+      );
+    }
+  }
+
+  /**
+   * Handles execution errors and returns appropriate error responses
+   */
+  private async handleExecutionError(
+    error: unknown,
+    context: Partial<AuditContext>
+  ): Promise<UseSecretResponse> {
+    if (error instanceof ToolError) {
+      writeError(error.message, {
+        level: 'ERROR',
+        code: error.code,
+        secretId: context.secretId,
+        domain: context.domain
+      });
+      return { success: false, error: error.message, code: error.code };
+    }
+    
+    if (error instanceof AuditedError) {
+      // Audit has already been written in executeSecretAction, just handle the error response
+      const errorMessage = error.message;
+      writeError(errorMessage, { 
+        level: 'ERROR', 
+        code: CONFIG.ERROR_CODE_EXECUTION_FAILED,
+        secretId: context.secretId,
+        domain: context.domain
+      });
+      return { success: false, error: errorMessage, code: CONFIG.ERROR_CODE_EXECUTION_FAILED };
+    }
+    
+    if (error instanceof z.ZodError) {
+      const hasInvalidUrl = error.errors.some(e => e.message === TEXT.ERROR_INVALID_URL);
+      const hasEmptyHeader = error.errors.some(e => e.message === TEXT.ERROR_EMPTY_HEADER_NAME);
+      const hasInvalidActionType = error.errors.some(e => 
+        e.path.includes('action') && e.path.includes('type')
+      );
+      const hasInvalidInjectionType = error.errors.some(e => 
+        e.path.includes('action') && e.path.includes('injectionType')
+      );
+      
+      const errorMessage = hasInvalidUrl ? TEXT.ERROR_INVALID_URL
+        : hasEmptyHeader ? TEXT.ERROR_EMPTY_HEADER_NAME
+        : hasInvalidActionType ? TEXT.ERROR_INVALID_METHOD
+        : hasInvalidInjectionType ? TEXT.ERROR_INVALID_INJECTION_TYPE
+        : TEXT.ERROR_INVALID_REQUEST;
+      const errorCode = hasInvalidUrl ? CONFIG.ERROR_CODE_INVALID_URL
+        : hasEmptyHeader ? CONFIG.ERROR_CODE_INVALID_HEADERS
+        : hasInvalidActionType ? CONFIG.ERROR_CODE_INVALID_METHOD
+        : hasInvalidInjectionType ? CONFIG.ERROR_CODE_INVALID_INJECTION_TYPE
+        : CONFIG.ERROR_CODE_INVALID_REQUEST;
+      
+      writeError(errorMessage, { level: 'ERROR', code: errorCode, details: error.errors });
+      return { success: false, error: errorMessage, code: errorCode };
+    }
+    
+    await this.auditRequest(context, TEXT.AUDIT_OUTCOME_ERROR, TEXT.ERROR_EXECUTION_FAILED);
+    
+    const errorMessage = error instanceof Error ? error.message : TEXT.ERROR_EXECUTION_FAILED;
+    writeError(errorMessage, { level: 'ERROR', code: CONFIG.ERROR_CODE_EXECUTION_FAILED });
+    return { success: false, error: errorMessage, code: CONFIG.ERROR_CODE_EXECUTION_FAILED };
+  }
+
+  /**
+   * Main execution method for the UseSecret tool
+   * Orchestrates validation, security checks, and action execution
+   */
+  async execute(args: unknown): Promise<UseSecretResponse> {
+    let context: Partial<AuditContext> = {};
+    
+    try {
+      const validated = await this.validateAndExtractRequest(args);
+      context = { 
+        secretId: validated.secretId, 
+        action: validated.action.type, 
+        domain: validated.domain 
+      };
+      
+      await this.enforceRateLimit(validated.secretId, validated.domain, validated.action.type);
+      await this.verifySecretExists(validated.secretId, validated.action.type, validated.domain);
+      await this.evaluateAccessPolicy(validated.secretId, validated.action.type, validated.domain);
+      
+      const secretValue = await this.retrieveSecretValue(
+        validated.secretId, 
+        validated.action.type, 
+        validated.domain
+      );
+      
+      const result = await this.executeSecretAction(
+        validated.action, 
+        secretValue, 
+        context as AuditContext
+      );
+      
+      return { success: true, result };
+    } catch (error) {
+      return this.handleExecutionError(error, context);
+    }
+  }
+}
\ No newline at end of file
